#include<stdio.h>
int main()
{

// sizeof(long) >= sizeof(int)
// 类型决定开辟的空间

    // char ch;          // 1
    // short num1;       // 2
    // int num2;         // 4
    // long num3;        // 4/8
    // long long num4;   // 8
    // float f;          // 4
    // double;           // 8

// 看待内存的视角
    // int a;  // 存放整形
    // float f; // 存放浮点数

// 整型家族
    /*
    char
        unsigned char
        signed char

    short
        unsigned short
        signed short

    int 
        unsigned int
        signed int

    long 
        unsigned long
        signed long

    long long
        unsigned long long
        signed long long
    */

    // char 是unsigned char还是signed char编译器决定的
    // 写代码是为了解决是生活 有些数据是没有负数的
    // int a
    // 00000000000000000000000000000000
    // 01111111111111111111111111111111 无符号最前面只能是零

    // unsigned  a
    // 10000000000000000000000000000000


// 浮点型家族 存储小数
    // float精度较低 存储范围低
    // double进度高 存储范围高


// 自定义类型
    /*
    数组
    int arr1[5]的类型 int [5],,int arr[8]的类型int [8]
    结构体
    枚举
    联合类型
    */

// 指针类型
    /*
    int* pi
    char* pc
    float* pf
    void* pv
    */

// 空类型
    /*
    void 函数返回值 函数参数值,指针类型
    void* 空类型指针类型 
    */
// 整型在内存中的存储 实际上是补码存储的
// 为什么存放补码
// 统一性:加法和减法统一了 源码反码补码---逻辑电路是一样的---补码反码源码
    /*
    00000000000000000000000000000001  1
    
    10000000000000000000000000000001  源码
    11111111111111111111111111111110  反码
    11111111111111111111111111111111  补码

    00000000000000000000000000000001  1补码
    11111111111111111111111111111111  -1补码
   100000000000000000000000000000000  最高位丢弃了
    */

    // int a = 20;
    // 00000000000000000000000000010100 源码    0x00000014十六进制表示
    // 00000000000000000000000000010100 反码    0x00000014十六进制表示
    // 00000000000000000000000000010100 补码    0x00000014十六进制表示

    // int b = -10;
    // 10000000000000000000000000001010 源码    0x800000a十六进制表示
    // 11111111111111111111111111110101 补码    0xffffff5十六进制表示
    // 11111111111111111111111111110110 补码    0xffffff6十六进制表示

    // 数组有不同表现形式 二进制 八进制 十进制 十六进制 
    // 二进制表示一个整数三种表现形式:反码 补码 源码
    // 正的整数 源码=反码=补码
    // 负的整数 源码，反码，补码

// 大小端(为什么补码形式是反着存放的) 是以字节的形式存放
// 大小端是根据多个字节来存储的

    // 大小端是硬件决定的
    /*
    0x11223344
    11 22 33 44 大端字节存储   低地址 --- 高地址
    44 33 22 11 小端字节存储   低地址 --- 高地址
    把一个数据的高位字节序的内存存放在低地址 把低位字节序的内容存放在高位出 就是大端存储
    把一个数据的高位字节序的内存存放在高地址 把低位字节序的内容存放在低位出 就是大端存储
    */

// 判断大小端存储
    int a = 1;
    char* ch = (char*)&a;  // 强制类型转换 只是访问一个字节的地址
    printf("%d\n", *ch);    // 打印该字节的值









    return 0;
}