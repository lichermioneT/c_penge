#include<stdio.h>
int main()
{   
    // c语言内置类型
    // char short  int long  long long float double  
    // sizeof(long) >= sizeof(int)

    // 类型的意义开辟空间的大小
    // 类型的意义如何看待内存的空间视角

// 整型家族
/*
    char  字符的本质是ASCII码值 是整型
        unsigned char
        signed char
        char  char的类型是 signed char 还是 unsigned char 取决于编译器决定的
    short
        unsigned short
        signed short
    int 
        unsigned int 
        signed int 
    long 
        unsigned long
        signed long
    long long
        unsigned long long
        signed long long 

*/
// 生活中有些数据是没有负数的
/*
    int a = 0;
    00000000000000000000000000000000
    第一位表示符号位：1负数，0正数。
    int a = 10;
    00000000000000000000000000001010

    unsigned int height;
    00000000000000000000000000000000
    全部都是有效位：第一位 恒为0


*/

// 浮点型家族
    /*
    float
    double
    */

// 自定义类型
    /*
    数组类型: int arr[5]的类型是 int [5] , int arr2[8]的类型是 int [8]  char ch[8]的类型是  char [8]
    数组类型：数组和元素个数都在变化 可以自己构造。自定义类型
    枚举类型
    结构体类型
    联合类型
    指针类型
    空类型 void 类型 void函数类型  void函数没有参数  void指针
    void* 指针
    */

// 整型在空间的存储
// 数值有不同的表示形式 不同的进制表示形式  二进制和十六进制转换十分方便的
// 整数的二进制表示形式原码 反码补码
// 正数的原码等于反码等于补码  原码==补码==反码
// 负数的 原码-->符号位不变（补码)-->加一（补码）

// 整型在计算机里面存储的是补码的二进制
// 补码按照大小端存储的
    // int a = 20;
    // 00000000000000000000000000010100  原码  0x00000014
    // 00000000000000000000000000010100  反码  0x00000014
    // 00000000000000000000000000010100  补码  0x00000014

    // int b = -10;
    // 10000000000000000000000000001010  原码  0x800000a
    // 11111111111111111111111111110101  原码  0xffffff5
    // 11111111111111111111111111110110  补码  0xffffff6

// 补码的形式存储就是为了只有加法 不需要额外的电路实现 
    // 20 - 10
    // 00000000000000000000000000010100  补码  0x00000014
    // 11111111111111111111111111110110  补码  0xffffff6
    // 00000000000000000000000000001010  10

    // 1-1
    // 00000000000000000000000000000001  补码
    // 11111111111111111111111111111111  补码
    // 00000000000000000000000000000000  补码
// 补码变成原码硬件电路一样不需要额外的电路

// 大小端取决于硬件存储的
// 内存里面实际上二进制存储数据 这里是十六进制
// 大小端 以字节顺序来地址
    // 大小端存储是按照字节来存的
    // 怎么存放怎么拿去出来
    // 0x11223344
    // 11223344 大端字节存储 先存放高位
    // 44332211 小端字节存储 先存放低位
    // 大端字节存储：数字高位放在低地址
    // 小端字节存储：数字低位放在低地址

// 判断大小端存储的顺序 
// 只需要判断数据一个特殊的地址
    // int a = 1;
    // 00000000000000000000000000000001
    // 0x00000001;
    // 00000001 大端存储
    // 10000000 小端存储

    // char* ch  = (char*)(&a);
    // printf("%d\n", *ch);  // 小端存储
    // if(*(char*)&a == 1)
    // {
    //     printf("小端\n");
    // }
    // else
    // {
    //     printf("大端\n");
    // }
// char没有字节存储顺序 一个字节 其它的都有的存储顺序
    
























    return 0;
}